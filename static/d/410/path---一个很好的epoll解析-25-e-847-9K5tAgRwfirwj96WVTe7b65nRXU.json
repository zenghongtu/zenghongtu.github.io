{"data":{"post":{"id":"289462f0-6a16-5122-ac92-e4b1dbd96226","html":"<p>title: 一个很好的epoll解析\nauthor: 大图\ntags:</p>\n<ul>\n<li>epoll\ncategories:</li>\n<li>\n<p>python\ndate: 2018-01-08 15:43:00</p>\n<hr>\n<h2>epoll介绍</h2>\n</li>\n</ul>\n<p>转自知乎</p>\n<p>作者：蓝形参(<a href=\"https://www.zhihu.com/people/thynson\">https://www.zhihu.com/people/thynson</a>)，Geek 伪技术宅</p>\n<p>首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。</p>\n<p>不管是文件，还是套接字，还是管道，我们都可以把他们看作流。</p>\n<p>之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？</p>\n<p>阻塞：阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。</p>\n<p>非阻塞忙轮询：接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”</p>\n<p>很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。</p>\n<p>大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。</p>\n<p>为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。</p>\n<p>假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。</p>\n<p>假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。</p>\n<p>但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。</p>\n<p>假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”</p>\n<p>也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。</p>\n<p>这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。</p>\n<p>然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。</p>\n<p>于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">while true {\n    for i in stream[]; {\n        if i has data\n            read until unavailable\n    }\n}</code></pre></div>\n<p>我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。</p>\n<p>为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。代码长这样:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">while true {\n    select(streams[])\n    for i in streams[] {\n        if i has data\n            read until unavailable\n    }\n}</code></pre></div>\n<p>于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。</p>\n<p>但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，没一次无差别轮询时间就越长。再次说了这么多，终于能好好解释epoll了</p>\n<p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</p>\n<p>在讨论epoll的实现细节之前，先把epoll的相关操作列出：</p>\n<p>epoll<em>create 创建一个epoll对象，一般epollfd = epoll</em>create()</p>\n<p>epoll<em>ctl （epoll</em>add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件</p>\n<p>比如</p>\n<p>epoll<em>ctl(epollfd, EPOLL</em>CTL_ADD, socket, EPOLLIN);//注册缓冲区非空事件，即有数据流入</p>\n<p>epoll<em>ctl(epollfd, EPOLL</em>CTL_DEL, socket, EPOLLOUT);//注册缓冲区非满事件，即流可以被写入</p>\n<p>epoll_wait(epollfd,…)等待直到注册的事件发生</p>\n<p>（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。</p>\n<p>一个epoll模式的代码大概的样子是：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">while true {\n    active_stream[] = epoll_wait(epollfd)\n    for i in active_stream[] {\n        read or write till\n    }\n}</code></pre></div>\n<p>限于篇幅，我只说这么多，以揭示原理性的东西，至于epoll的使用细节，请参考man和google，实现细节，请参阅linux kernel source。</p>\n<h2>个人总结</h2>\n<p>看完以上对于epoll的介绍，对于linux中的IO模型有了一定的认知\n相比于传统的select/poll模型，epoll利用了事件通知的形式，减少了接受IO信号后对所有socket进行轮询的开销，大大提升效率</p>\n<p>epoll是linux所特有，而select是POSIX所规定，一般操作系统均有实现。</p>\n<p>关于linux中的几种IO模型介绍：\nselect：查找</p>\n<p>select本质是通过设置或检查存放fd标志位的数据结构来进行下一步处理。缺点是：</p>\n<p>1、单个进程可监视的fd数量被限制，即能监听端口的大小有限。</p>\n<p>一般来说和系统内存有关，具体数目可以cat /proc/sys/fs/file-max察看。32位默认是1024个，64位默认为2048个</p>\n<p>2、对socket进行扫描时是线性扫描，即采用轮询方法，效率低。</p>\n<p>当套接字比较多的时候，每次select()都要遍历FD_SETSIZE个socket来完成调度，不管socket是否活跃都遍历一遍。会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，就避免了轮询，这正是epoll与kqueue做的</p>\n<p>3、需要维护一个用来存放大量fd的数据结构，会使得用户空间和内核空间在传递该结构时复制开销大\npoll：</p>\n<p>poll本质和select相同，将用户传入的数据拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或主动超时，被唤醒后又要再次遍历fd</p>\n<p>它没有最大连接数的限制，原因是它是基于链表来存储的，但缺点是：</p>\n<p>1、大量的fd的数组被整体复制到用户态和内核空间之间，不管有无意义。</p>\n<p>2、poll还有一个特点“水平触发”，如果报告了fd后，没有被处理，那么下次poll时再次报告该ffd。\nepoll：</p>\n<p>epoll支持水平触发和边缘触发，最大特点在于边缘触发，只告诉哪些fd刚刚变为就绪态，并且只通知一次。还有一特点是，epoll使用“事件”的就绪通知方式，通过epoll<em>ctl注册fd，一量该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll</em>wait便可以收到通知。</p>\n<p>epoll的优点：</p>\n<p>1、没有最大并发连接的限制</p>\n<p>2、效率提升，只有活跃可用的FD才会调用callback函数</p>\n<p>3、内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递。</p>\n<p>select、poll、epoll区别总结：</p>\n<p>1、支持一个进程打开连接数</p>\n<p>select：32位机器1024个，64位2048个</p>\n<p>poll：无限制，原因基于链表存储</p>\n<p>epoll：有上限，但很大，2G内存20W左右</p>\n<p>2、IO效率</p>\n<p>select：IO效率低</p>\n<p>poll：IO效率低</p>\n<p>epoll：只有活跃的socket才调用callback，IO效率高。</p>\n<p>3、消息传递方式</p>\n<p>select：内核需要将消息传递到用户空间，都需要内核拷贝动作</p>\n<p>poll：同上</p>\n<p>epoll：通过内核与用户空间共享一块内存来实现。</p>","fields":{"slug":"/一个很好的epoll解析/","prefix":null},"frontmatter":{"title":"","author":null,"category":null,"cover":null}},"authornote":{"id":"f3ffdeef-a16f-507d-9f2f-98fa5e045d0b","html":"<p><strong>Mr. Gatsby</strong> Proin ornare ligula eu tellus tempus elementum. Aenean <a href=\"/\">bibendum</a> iaculis mi, nec blandit lacus interdum vitae. Vestibulum non nibh risus, a scelerisque purus. Blandit lacus interdum vitae. Vestibulum non nibh risus, a scelerisque purus.</p>"},"site":{"siteMetadata":{"facebook":{"appId":""}}}},"pageContext":{"slug":"/一个很好的epoll解析/","next":{"id":"e23bf336-a5d5-5e40-b2eb-f612590a4bb8","fields":{"slug":"/scrapy-redis设置不同db/","prefix":null,"source":"posts"},"frontmatter":{"title":"","category":null}},"source":"posts"}}